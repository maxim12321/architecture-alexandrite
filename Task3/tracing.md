# Архитектурное решение по трейсингу

Трейсинг будет полезен для всех API: `Shop API`, `CRM API`, `MES API`. Эти сервисы ходят во внешние - базы данных,
очередь событий, S3, все это хорошо бы видеть на трейсах. Но надо будет решить, какие из них покрывать трейсингом,
а для каких это обойдется слишком дорого...

Помимо `trace_id` и `span_id` в трассах полезна будет дополнительная информация:
* название сервиса (`Shop API`, `MES API` и тд)
* название окружения (dev/prod)
* текущий эндпоинт (http-путь)
* таймстемп запроса
* **ID заказа** -- очень поможет отслеживать запросы по конкретному заказу

## Мотивация

В первую очередь трейсинг даст возможность расследовать случившиеся проблемы с заказами. Например, если пользователь
обращается с тем, что его заказ потеряли, по ID заказа можно будет просмотреть все изменения в системе, связанные
с этим заказом, в том числе время, когда они были сделаны.

С точки зрения бизнес-метрик, это поможет повысить показатель удовлетворенности клиентов интернет-магазина, так как
по трейсам можно будет искать баги в системе и устранять их. Как следствие, это повысит коэффициент удержания
пользователей (retention).

Также в будущем, в результате расследования проблемных заказов и устранения багов, система будет становиться
более стабильной, генерируя меньше обращений в поддержку как от клиентов интернет-магазина, так и от B2B-клиентов.

С технической точки зрения, трейсинг поможет выявить узкие места в системе, чтобы затем оптимизировать
производительность сервисов. Можно пользоваться данными трассировок для настройки таймаутов в будущем.

Также трейсинг позволяет ускорить диагностику ошибок, улучшая рабочие процессы и освобождая ресурсы разработчиков.

## Предлагаемое решение

Трейсинг предлагается реализовывать с использованием `Jaeger`, для которого есть экспортеры на разных языках,
в том числе Java (на котором написаны `Shop API` и `CRM API`). Бэкенду `Jaeger` понадобится хранилище, так как
дефолтный `in-memory` вариант нам не подойдет. Можно развернуть под это сразу кластер `Elasticsearch`, он в любом
случае пригодится в дальнейшем при настройке логов.

Также, для обеспечения безопасности и ограничения доступа к `Jaeger UI` необходимо настроить прокси, через
который будут проходить все обращения к интерфейсу. Так как в команде бэкенда больше всего ресурсов на `Java`,
можно реализовать этот прокси тоже на `Spring Boot`. Хоть это и излишне тяжеловесное решение, оно потребует
меньше сил для настройки, особенно учитывая, что эти разработчики настраивали авторизацию для других API.

Альтернативно, можно поднять `Keycloak` инстанс в качестве такого прокси, это потребует меньше усилий для настройки.
Однако такой подход может все равно занять больше времени, т.к. при отсутствии опыта разработчиков/DevOps с этой
технологией могут понадобиться курсы и прочее.

Сбор трейс-логов для начала необходимо настроить для `Shop API`, вторым приоритетом - еще и для `MES API`, возможно
позже других задач. Пониженный приоритет на диаграмме отметил пунктирной связью.

[Ссылка на просмотр обновленной диаграммы](https://drive.google.com/file/d/1swcexgVMFx-yX-nb-9OoRzQGWQU63C_c/view?usp=sharing), исходный DrawIO файл в текущей директории.

## Компромиссы

Во-первых, в `CRM API` хоть и не помешали бы трейсы, но это слабо поможет в текущий проблемах компании. Дело в том,
что `CRM` отвечает только за статус заказа `MANUFACTURING_APPROVED`, а также за финальный `CLOSED`, когда заказ
уже дошел до клиента.
Следовательно, зависание в статусе `MANUFACTURING_APPROVED` в целом можно отслеживать другим способом, не инвестируя
ресурсы в доработку и отложив это на будущее.

Внедрение трейсинга в `MES API` может стать слишком дорогим для компании, т.к. система была приобретена вместе
с исходным кодом. В целом, в команде есть один разработчик `C#`, который может заняться этим, еще и тимлид -- бывший
`C#` разработчик, который сможет помочь в выгрузке трейсов. Но для начала следует делать более приоритетные задачи,
которые принесут больше ценности в условии сжатых сроков.

## Безопасность

Во-первых, необходимо ограничить доступ к хранилищу Jaeger'а. В целом, это решается на уровне самой базы данных,
используемой в качестве хранилища.

На данный момент остается только закрыть `Jaeger UI` для всех, кроме сотрудников компании, желательно еще и с
определенной ролью в системе. Для того, чтобы сделать это быстро, можно перед `UI` поставить прокси, который
будет выполнять аутентификацию и авторизацию. Чтобы не изобретать велосипед в этом месте, проще всего
воспользоваться существующими сервисами. Например, `Keycloak` позволит небольшими усилиями добавить ролевую модель,
особенно если у кого-то в команде уже был опыт в настройке подобных систем.

В остальном, если корректно отправлять данные по сети, используя защищенные каналы, все должно быть в порядке.
