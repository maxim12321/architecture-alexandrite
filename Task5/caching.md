# Архитектурное решение по кешированию

В первую очередь стоит настраивать кэширование в том месте, где уже сейчас наблюдаются проблемы с
производительностью. Начать стоит с `MES API`, т.к. его использует интерфейс для операторов, которые исполняют
заказы. Они уже жаловались на то, что система "тормозит" и долго открывает список заказов.

Для `MES API` имеет смысл кэшировать те данные, которые запрашивает `MES`-интерфейс и внешние пользователи API.

Далее, хорошо бы добавить кэширование `Shop API` для улучшения пользовательского опыта в интернет-магазине.
Это еще одно место, где нагрузка постоянно растет, а правильная настройка кэширования позволит уменьшить затраты
на сервера и разгрузить базу данных.

## Мотивация

Последнее время в компании участились жалобы операторов на то, что первая страница `MES` долго загружается. Это
влияет на скорость исполнения заказов, ведь операторы берут заказ на выполнение именно через этот сервис. Долгая
загрузка сайта влияет на скорость выполнения заказов, а следовательно порождает еще и жалобы клиентов
интернет-магазина и B2B-клиентов на задержки изготовления, что ведет к потенциальной потере прибыли.

Кэширование в этой ситуации может помочь ускорить систему, разгрузив ее от многочисленных запросов чтения с главной
страницы сайта. Если хранить в кэше статус для каждого заказа, а также `id` оператора, который принял этот заказ
в работу, серверу `MES API` чаще всего даже не придется ходить в `MES db`, которая на данный момент может быть
узким местом во всей системе. Реляционные базы данных масштабируются не тривиально, поэтому кэширование станет
быстрым решением для уменьшения нагрузки на БД.

Также нагрузка на интернет-магазин постоянно растет, поэтому компания может упереться в нехватку ресурсов для
`Shop API` или даже скорее `Shop DB`. В этом месте кэширование снова поможет меньшими усилиями разгрузить и
сами `API`, и базу данных. Иначе, масштабирование `API` потребовало бы настраивать прокси/BFF/ApiGW, ну или
пришлось бы масштабировать базу данных, если бы она была причиной потери производительности.

Таким образом, кэширование в `MES API` и `Shop API` поможет значительно снизить нагрузку на серверы и увеличить
производительность системы в целом, что будет положительно влиять на пользовательский опыт и уменьшит жалобы как
клиентов магазина, так и операторов.

## Предлагаемое решение

Для `MES API` предлагается использовать серверное кэширование на запросы получения списка заказов с фильтрацией
по статусам и тд, так как там нужна будет особенная инвалидация. Если сделать кэширование на стороне клиента в
данном случае, операторы могут наблюдать странное поведение системы и испытывать проблемы с тем, чтобы брать
заказы в обработку.

Для серверного кэширования будем использовать паттерн `Cache-Aside`, настроив `Redis`. Такой способ поможет
улучшить отказоустойчивость системы и сохранив расширяемость системы (легко добавлять и изменять способ кэширования
для отдельных ручек API). Остальные варианты могут повлиять на работоспособность системы, если кэш недоступен,
что может привести к дополнительным задержкам в обработке заказов или потере данных.

Для некоторых запросов `Shop API` (получение статуса заказа и тд) можно также настроить `Cache-Aside` серверное
кэширование, причем использовать тот же самый `Redis`-кластер, ведь в нем уже хранятся статусы заказов.

При кэшировании статуса заказов важно правильно настроить инвалидацию. В данном случае стоит использовать
комбинацию:
* **временная** инвалидация для очистки кэша устаревших данных
* **инвалидация по ключу** -- при обновлении статуса заказа в `MES API` нужно инвалидировать кэш конкретно для
этого заказа по ID, чтобы при этом не потерять закэшированные данные для других заказов.

Инвалидация, основанная на запросах, тут точно не подойдет, так как запросы пользователей -- не единственный
источник информации об обновлении статуса заказа. События обновления приходят из очереди `RabbitMQ`, в этом
случае также необходимо сбросить данные в кэше.

Отдельно для интернет-магазина можно добавить HTTP-кэширование на стороны клиента для отдельных страниц. Например,
хорошо подойдет он для страницы каталога товаров, где задержка в обновлении не имеет значения (конечно, речь о
небольшой задержке, скажем, минута). Это может хорошо работать как в случае с общим каталогом для всех
пользователей, так и при добавлении рекомендательных систем в будущем.

[Ссылка на sequence-диаграмму](https://drive.google.com/file/d/1OcXLcG5eyQ0M541jPo2MQLn7ilwZBFxw/view?usp=sharing)
для получения и обновления статуса заказа в `MES API` с настроенным серверным `Cache-Aside` кэшированием. Исходный
DrawIO файл в текущей директории.
